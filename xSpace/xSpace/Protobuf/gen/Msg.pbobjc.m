// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Msg.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - LPBMsgRoot

@implementation LPBMsgRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - LPBMsgRoot_FileDescriptor

static GPBFileDescriptor *LPBMsgRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"main"
                                                 objcPrefix:@"LPB"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - LPBUser

@implementation LPBUser

@dynamic userId;
@dynamic name;
@dynamic gender;
@dynamic role;
@dynamic level;
@dynamic hao;
@dynamic medalsArray, medalsArray_Count;
@dynamic avatar;
@dynamic fanId;

typedef struct LPBUser__storage_ {
  uint32_t _has_storage_[1];
  int32_t role;
  int32_t level;
  int32_t hao;
  int32_t fanId;
  NSString *userId;
  NSString *name;
  NSString *gender;
  GPBInt32Array *medalsArray;
  NSString *avatar;
} LPBUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = LPBUser_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LPBUser__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = LPBUser_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LPBUser__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gender",
        .dataTypeSpecific.className = NULL,
        .number = LPBUser_FieldNumber_Gender,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LPBUser__storage_, gender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "role",
        .dataTypeSpecific.className = NULL,
        .number = LPBUser_FieldNumber_Role,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LPBUser__storage_, role),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = LPBUser_FieldNumber_Level,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LPBUser__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "hao",
        .dataTypeSpecific.className = NULL,
        .number = LPBUser_FieldNumber_Hao,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LPBUser__storage_, hao),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "medalsArray",
        .dataTypeSpecific.className = NULL,
        .number = LPBUser_FieldNumber_MedalsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LPBUser__storage_, medalsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = LPBUser_FieldNumber_Avatar,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LPBUser__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fanId",
        .dataTypeSpecific.className = NULL,
        .number = LPBUser_FieldNumber_FanId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LPBUser__storage_, fanId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LPBUser class]
                                     rootClass:[LPBMsgRoot class]
                                          file:LPBMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LPBUser__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LPBData

@implementation LPBData

@dynamic message;
@dynamic amount;
@dynamic rewardName;
@dynamic rewardImage;
@dynamic id_p;
@dynamic isBarrage;
@dynamic showCountList;
@dynamic animationURL;
@dynamic comboId;
@dynamic comboAmount;
@dynamic systemMessage;
@dynamic rewardIndex;
@dynamic barrageType;
@dynamic rewardName1;
@dynamic rewardImage1;
@dynamic liveshowURL;
@dynamic podcasterName;
@dynamic template_p;
@dynamic streamType;
@dynamic hlsPlayURL;
@dynamic mp3PlayURL;
@dynamic event;
@dynamic rewardId;
@dynamic level;
@dynamic nextLevel;
@dynamic privilegesArray, privilegesArray_Count;
@dynamic nextPrivilegesArray, nextPrivilegesArray_Count;
@dynamic endTime;
@dynamic userId;
@dynamic imgURL;
@dynamic title;
@dynamic redirectURL;
@dynamic r;
@dynamic t;
@dynamic n;
@dynamic reco;
@dynamic status;
@dynamic programId;
@dynamic agoraKey;
@dynamic agoraKeyTtl;
@dynamic enter;
@dynamic notice;
@dynamic rulesArray, rulesArray_Count;
@dynamic redPacketId;
@dynamic shares;
@dynamic emptyAt;
@dynamic expiresAt;
@dynamic claimedAmount;
@dynamic nickName;
@dynamic popup;
@dynamic waitLeftMs;

typedef struct LPBData__storage_ {
  uint32_t _has_storage_[2];
  int32_t amount;
  int32_t id_p;
  int32_t comboAmount;
  int32_t rewardIndex;
  int32_t barrageType;
  int32_t rewardId;
  int32_t level;
  int32_t nextLevel;
  int32_t r;
  int32_t t;
  int32_t n;
  int32_t reco;
  int32_t status;
  int32_t programId;
  int32_t agoraKeyTtl;
  int32_t enter;
  int32_t shares;
  int32_t claimedAmount;
  int32_t waitLeftMs;
  NSString *message;
  NSString *rewardName;
  NSString *rewardImage;
  NSString *animationURL;
  NSString *systemMessage;
  NSString *rewardName1;
  NSString *rewardImage1;
  NSString *liveshowURL;
  NSString *podcasterName;
  NSString *template_p;
  NSString *streamType;
  NSString *hlsPlayURL;
  NSString *mp3PlayURL;
  NSString *event;
  NSMutableArray *privilegesArray;
  NSMutableArray *nextPrivilegesArray;
  NSString *endTime;
  NSString *userId;
  NSString *imgURL;
  NSString *title;
  NSString *redirectURL;
  NSString *agoraKey;
  NSString *notice;
  NSMutableArray *rulesArray;
  NSString *redPacketId;
  NSString *emptyAt;
  NSString *expiresAt;
  NSString *nickName;
  int64_t comboId;
} LPBData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LPBData__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LPBData__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "rewardName",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_RewardName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LPBData__storage_, rewardName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rewardImage",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_RewardImage,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LPBData__storage_, rewardImage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Id_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LPBData__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isBarrage",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_IsBarrage,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "showCountList",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_ShowCountList,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "animationURL",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_AnimationURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LPBData__storage_, animationURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "comboId",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_ComboId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(LPBData__storage_, comboId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "comboAmount",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_ComboAmount,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(LPBData__storage_, comboAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "systemMessage",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_SystemMessage,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(LPBData__storage_, systemMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rewardIndex",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_RewardIndex,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(LPBData__storage_, rewardIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "barrageType",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_BarrageType,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(LPBData__storage_, barrageType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "rewardName1",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_RewardName1,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(LPBData__storage_, rewardName1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rewardImage1",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_RewardImage1,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(LPBData__storage_, rewardImage1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "liveshowURL",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_LiveshowURL,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(LPBData__storage_, liveshowURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "podcasterName",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_PodcasterName,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(LPBData__storage_, podcasterName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "template_p",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Template_p,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(LPBData__storage_, template_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "streamType",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_StreamType,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(LPBData__storage_, streamType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hlsPlayURL",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_HlsPlayURL,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(LPBData__storage_, hlsPlayURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mp3PlayURL",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Mp3PlayURL,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(LPBData__storage_, mp3PlayURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "event",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Event,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(LPBData__storage_, event),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rewardId",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_RewardId,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(LPBData__storage_, rewardId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Level,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(LPBData__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nextLevel",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_NextLevel,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(LPBData__storage_, nextLevel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "privilegesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LPBPrivilege),
        .number = LPBData_FieldNumber_PrivilegesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LPBData__storage_, privilegesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextPrivilegesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LPBPrivilege),
        .number = LPBData_FieldNumber_NextPrivilegesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LPBData__storage_, nextPrivilegesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_EndTime,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(LPBData__storage_, endTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_UserId,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(LPBData__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgURL",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_ImgURL,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(LPBData__storage_, imgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Title,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(LPBData__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "redirectURL",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_RedirectURL,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(LPBData__storage_, redirectURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "r",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_R,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(LPBData__storage_, r),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "t",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_T,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(LPBData__storage_, t),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "n",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_N,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(LPBData__storage_, n),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reco",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Reco,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(LPBData__storage_, reco),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Status,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(LPBData__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "programId",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_ProgramId,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(LPBData__storage_, programId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "agoraKey",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_AgoraKey,
        .hasIndex = 38,
        .offset = (uint32_t)offsetof(LPBData__storage_, agoraKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "agoraKeyTtl",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_AgoraKeyTtl,
        .hasIndex = 39,
        .offset = (uint32_t)offsetof(LPBData__storage_, agoraKeyTtl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "enter",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Enter,
        .hasIndex = 40,
        .offset = (uint32_t)offsetof(LPBData__storage_, enter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "notice",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Notice,
        .hasIndex = 41,
        .offset = (uint32_t)offsetof(LPBData__storage_, notice),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rulesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LPBRule),
        .number = LPBData_FieldNumber_RulesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LPBData__storage_, rulesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "redPacketId",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_RedPacketId,
        .hasIndex = 42,
        .offset = (uint32_t)offsetof(LPBData__storage_, redPacketId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shares",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Shares,
        .hasIndex = 43,
        .offset = (uint32_t)offsetof(LPBData__storage_, shares),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "emptyAt",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_EmptyAt,
        .hasIndex = 44,
        .offset = (uint32_t)offsetof(LPBData__storage_, emptyAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expiresAt",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_ExpiresAt,
        .hasIndex = 45,
        .offset = (uint32_t)offsetof(LPBData__storage_, expiresAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "claimedAmount",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_ClaimedAmount,
        .hasIndex = 46,
        .offset = (uint32_t)offsetof(LPBData__storage_, claimedAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_NickName,
        .hasIndex = 47,
        .offset = (uint32_t)offsetof(LPBData__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "popup",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_Popup,
        .hasIndex = 48,
        .offset = 49,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "waitLeftMs",
        .dataTypeSpecific.className = NULL,
        .number = LPBData_FieldNumber_WaitLeftMs,
        .hasIndex = 50,
        .offset = (uint32_t)offsetof(LPBData__storage_, waitLeftMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LPBData class]
                                     rootClass:[LPBMsgRoot class]
                                          file:LPBMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LPBData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\014\003\n\000\004\013\000\006\t\000\007\r\000\010\n!!\000\014\013\000\020\010\241!!\000\024\003\244\241!!\000\025\003\244\241!!"
        "\000\035\007\000\037\003\241!!\000!\010\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LPBRule

@implementation LPBRule

@dynamic title;
@dynamic link;

typedef struct LPBRule__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *link;
} LPBRule__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = LPBRule_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LPBRule__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "link",
        .dataTypeSpecific.className = NULL,
        .number = LPBRule_FieldNumber_Link,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LPBRule__storage_, link),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LPBRule class]
                                     rootClass:[LPBMsgRoot class]
                                          file:LPBMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LPBRule__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LPBPrivilege

@implementation LPBPrivilege

@dynamic icon;
@dynamic name;
@dynamic level;

typedef struct LPBPrivilege__storage_ {
  uint32_t _has_storage_[1];
  int32_t level;
  NSString *icon;
  NSString *name;
} LPBPrivilege__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "icon",
        .dataTypeSpecific.className = NULL,
        .number = LPBPrivilege_FieldNumber_Icon,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LPBPrivilege__storage_, icon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = LPBPrivilege_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LPBPrivilege__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = LPBPrivilege_FieldNumber_Level,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LPBPrivilege__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LPBPrivilege class]
                                     rootClass:[LPBMsgRoot class]
                                          file:LPBMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LPBPrivilege__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LPBBody

@implementation LPBBody

@dynamic type;
@dynamic hasData_p, data_p;
@dynamic hasUser, user;

typedef struct LPBBody__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  LPBData *data_p;
  LPBUser *user;
} LPBBody__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = LPBBody_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LPBBody__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(LPBData),
        .number = LPBBody_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LPBBody__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(LPBUser),
        .number = LPBBody_FieldNumber_User,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LPBBody__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LPBBody class]
                                     rootClass:[LPBMsgRoot class]
                                          file:LPBMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LPBBody__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LPBMessage

@implementation LPBMessage

@dynamic type;
@dynamic hasData_p, data_p;
@dynamic hasUser, user;

typedef struct LPBMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  LPBData *data_p;
  LPBUser *user;
} LPBMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = LPBMessage_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LPBMessage__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(LPBData),
        .number = LPBMessage_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LPBMessage__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(LPBUser),
        .number = LPBMessage_FieldNumber_User,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LPBMessage__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LPBMessage class]
                                     rootClass:[LPBMsgRoot class]
                                          file:LPBMsgRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LPBMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
